package main

import (
	"bytes"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"path"
	"time"

	"golang.org/x/crypto/ssh"

	"github.com/mholt/archiver"
	"github.com/pkg/sftp"
)

func main() {
	archiver.Zip.Make("output.zip", []string{"../testing/test"})
	sync(false)
	sync(true)
	openZip()
	upload()
	download()
}

func openZip() {
	defer timeTrack(time.Now(), "open zip")
	archiver.Zip.Open("output.zip", "./")

	// files, _ := ioutil.ReadDir("./test")
	// for _, f := range files {
	// 	fmt.Println(f.Name())
	// }
}

// PublicKeyFiles is used to accessing the remote filesystem
func PublicKeyFile(file string) ssh.AuthMethod {
	buffer, err := ioutil.ReadFile(file)
	if err != nil {
		return nil
	}

	key, err := ssh.ParsePrivateKey(buffer)
	if err != nil {
		return nil
	}
	return ssh.PublicKeys(key)
}

// syncUp pushes the latest versions of all the documents to the remote
func sync(up bool) {
	defer timeTrack(time.Now(), "pushing")
	// open an SFTP session over an existing ssh connection.
	sshConfig := &ssh.ClientConfig{
		User: "zns",
		Auth: []ssh.AuthMethod{
			PublicKeyFile("/home/zns/.ssh/id_rsa"),
		},
	}
	connection, err := ssh.Dial("tcp", "cowyo.com:22", sshConfig)
	defer connection.Close()

	sftp, err := sftp.NewClient(connection)
	if err != nil {
		log.Fatal(err)
	}
	defer sftp.Close()
	if up {
		f, err := sftp.Create(path.Join("/home/zns/test.zip"))
		fileContents, _ := ioutil.ReadFile("output.zip")
		if _, err = f.Write(fileContents); err != nil {
			log.Fatal(err)
		}
		f.Close()
	} else {
		fp, err := sftp.Open("/home/zns/test.zip")
		if err != nil {
			log.Fatal(err)
		}

		buf := bytes.NewBuffer(nil)
		_, err = io.Copy(buf, fp)
		if err != nil {
			log.Fatal(err)
		}
		fp.Close()

		err = ioutil.WriteFile("test.zip", buf.Bytes(), 0644)
		if err != nil {
			log.Fatal(err)
		}
	}
}

func upload() {
	defer timeTrack(time.Now(), "sent!")
	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go
	file, err := os.Open("./output.zip")
	defer file.Close()
	req, err := http.NewRequest("POST", "https://edvcfs.schollz.com/post", file)
	if err != nil {
		// handle err
	}
	req.SetBasicAuth("username", "password")
	req.Header.Set("Content-Type", "application/octet-stream")

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		// handle err
	}
	_, err = io.Copy(os.Stdout, resp.Body)
	if err != nil {
		log.Fatal(err)
	}
	defer resp.Body.Close()
}

func download() {
	defer timeTrack(time.Now(), "download")
	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go

	req, err := http.NewRequest("GET", "https://edvcfs.schollz.com/json", nil)
	if err != nil {
		// handle err
	}
	req.SetBasicAuth("username", "password")

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		// handle err
	}
	defer resp.Body.Close()

	outFile, err := os.Create("username" + ".zip")
	if err != nil {
		panic(err)
	}
	// handle err
	defer outFile.Close()
	_, err = io.Copy(outFile, resp.Body)
}

func timeTrack(start time.Time, name string) {
	elapsed := time.Since(start)
	log.Printf("%s took %s", name, elapsed)
}
